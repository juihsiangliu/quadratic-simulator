head	1.18;
access;
symbols;
locks
	d96041:1.18; strict;
comment	@ * @;


1.18
date	2010.11.14.12.48.53;	author d96041;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.09.09.10.45;	author d96041;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.08.12.57.41;	author d96041;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.17.08.56.55;	author d96041;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.12.05.55.02;	author d96041;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.28.08.42.46;	author d96041;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.04.07.37.08;	author d96041;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.03.10.00.09;	author d96041;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.02.06.59.54;	author d96041;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.01.12.30.28;	author d96041;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.30.09.48.16;	author d96041;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.30.03.50.00;	author d96041;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.29.13.35.35;	author d96041;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.28.12.54.28;	author r97124;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.28.10.03.26;	author r97124;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.25.09.42.26;	author r97124;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.25.07.22.57;	author r97124;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.25.03.01.00;	author r97124;	state Exp;
branches;
next	;


desc
@@


1.18
log
@ok version
use new cross term refinement
the version before this can not partition the graph more than 1M
@
text
@#include "partition_double.h"


static void sparseDoubleMatrix2AmdAi(int *ai,const SparseDoubleMatrix *a)
{
	const int totalRow = a->totalRow;
	int i;
	int index = 0;
	SparseDoubleElement *current;
	for(i=0;i<totalRow;i++)
	{
		current = a->rowIndex[i]->rowLink;
		while(current!=NULL)
		{
			ai[index] = current->col;
			index++;
			current = current->rowLink;
		}
	}
}



static void sparseDoubleMatrix2AmdAp(int *ap,const SparseDoubleMatrix *a)
{
	const int totalRow = a->totalRow;
	int i;
	int index = 0;
	int numInRow = 0;
	SparseDoubleElement *current;
	ap[0] = 0;
	for(i=0;i<totalRow;i++)
	{
		current = a->rowIndex[i]->rowLink;
		numInRow = 0;
		while(current!=NULL)
		{
			numInRow++;
			current = current->rowLink;
		}
		ap[i+1] = ap[i] + numInRow;
	}	
}



static void sparseDoubleMatrix2MetisADJNCY(idxtype *ai,const SparseDoubleMatrix *a)
{
	const int totalRow = a->totalRow;
	int i;
	int index = 0;
	SparseDoubleElement *current;
	for(i=0;i<totalRow;i++)
	{
		current = a->rowIndex[i]->rowLink;
		while(current!=NULL)
		{
			const int val = current->col;
			if(val == i)
			{
				current = current->rowLink;
				continue;
			}
			else
			{
				ai[index] = val;
				index++;
				current = current->rowLink;
			}
		}
	}
}



static void sparseDoubleMatrix2MetisXADJ(idxtype *ap,const SparseDoubleMatrix *a)
{
	const int totalRow = a->totalRow;
	int i;
	int index = 0;
	int numInRow = 0;
	SparseDoubleElement *current;
	ap[0] = 0;
	for(i=0;i<totalRow;i++)
	{
		current = a->rowIndex[i]->rowLink;
		numInRow = 0;
		while(current!=NULL)
		{
			numInRow++;
			current = current->rowLink;
		}
		ap[i+1] = ap[i] + numInRow;
	}	
	
	for(i=1;i<=totalRow;i++) ap[i] = ap[i] - i;
}



static void postorder2Permutation(SparseDoubleMatrix *p, const int *orderList)
{
	int i;	
	clearSparseDoubleMatrix(p);
	// the permutation matrix
	for(i=0;i<p->totalRow;i++)
	{
		setSparseDoubleMatrix(p,1,i,orderList[i]);
	}
}




static PartitionResult* createPartitionResult(const int partitionSize)
{
	PartitionResult *ptr = getMempoolSet(sizeof(PartitionResult));
	ptr->partitionSize = partitionSize;
	ptr->partA = getMempoolSet(sizeof(int)*partitionSize);
	ptr->partB = getMempoolSet(sizeof(int)*partitionSize);

	ptr->partASize = 0;
	ptr->partBSize = 0;

	ptr->crossList = getMempoolSet(sizeof(int)*2*partitionSize);
	ptr->crossListSize = 0;

	ptr-> visitLog = notvisit;

	ptr->partSerialBegin = ptr->partSerialEnd = -1;
	return ptr;
}


static void freePartitionResult(PartitionResult *ptr)
{
	retMempoolSet(ptr->partA,sizeof(int)*ptr->partitionSize);
	retMempoolSet(ptr->partB,sizeof(int)*ptr->partitionSize);
	retMempoolSet(ptr->crossList,sizeof(int)*2*ptr->partitionSize);
	retMempoolSet(ptr,sizeof(PartitionResult));
}




static void insertToPartitionResult(PartitionResult *result, const int val, const char flag) // flag = 'A' or flag = 'B'
{
	switch(flag)
	{
		case 'A':
			if(result->partASize == result->partitionSize)
			{
				fprintf(stderr,"error in insertToPartitionResult\n");
				exit(0);
			}
			else
			{
				result->partA[result->partASize] = val;
				result->partASize++;
			}
			break;
		case 'B':
			if(result->partBSize == result->partitionSize)
			{
				fprintf(stderr,"error in insertToPartitionResult\n");
				exit(0);
			}
			else
			{
				result->partB[result->partBSize] = val;
				result->partBSize++;
			}
			break;
		case 'C':  // add to cross list
			if(result->crossListSize == 2*result->partitionSize)
			{
				fprintf(stderr,"error in insertToPartitionResult\n");
				exit(0);
			}
			else
			{
				result->crossList[result->crossListSize] = val;
				result->crossListSize++;
			}
			break;
		default:
			fprintf(stderr,"error in insertToPartitionResult, wrong flag\n");
			exit(0);
	}
}



static gdsl_element_t alloc_partitionResult(void *ptr)
{
	PartitionResult *n = (PartitionResult *) ptr;
	PartitionResult *value = createPartitionResult(n->partitionSize);

	// copy from n to value
	value->partASize = n->partASize;
	value->partBSize = n->partBSize;
	value->crossListSize = n->crossListSize;

	memcpy(value->partA,n->partA,n->partASize*sizeof(int));
	memcpy(value->partB,n->partB,n->partBSize*sizeof(int));
	memcpy(value->crossList,n->crossList,n->crossListSize*sizeof(int));

	value->partSerialBegin = n->partSerialBegin;
	value->partSerialEnd = n->partSerialEnd;

	return (gdsl_element_t) value;
}


static void free_partitionResult(gdsl_element_t e)
{
	freePartitionResult(e);
}



static PartitionResult *allocAndCopyPartitionResult(const  PartitionResult *src,const char flag)
{
	PartitionResult *dest = createPartitionResult(src->partitionSize);
	switch(flag)
	{
		case 'A':
			dest->partASize = src->partASize;
			memcpy(dest->partA,src->partA,src->partASize*sizeof(int));
			break;
		case 'B':
			dest->partBSize = src->partBSize;
			memcpy(dest->partB,src->partB,src->partBSize*sizeof(int));
			break;
		case 'C':
			dest->crossListSize = src->crossListSize;
			memcpy(dest->crossList,src->crossList,src->crossListSize*sizeof(int));
			break;
		default:
			dest->partASize = src->partASize;
			memcpy(dest->partA,src->partA,src->partASize*sizeof(int));
			dest->partBSize = src->partBSize;
			memcpy(dest->partB,src->partB,src->partBSize*sizeof(int));
			dest->crossListSize = src->crossListSize;
			memcpy(dest->crossList,src->crossList,src->crossListSize*sizeof(int));
	}

	return dest;
}



// ==================================================  the utility in KL


// assuming ai and bj are exchanged, ai is original in partA and bj is original in partB
static void updataD
(int *D,const SparseDoubleMatrix *g,const int ai,const int bj,const PartitionResult* partition,const enum LockStat* lockTable)
{
	int i;

	// updatd Dx'
	for(i=0;i<partition->partASize;i++)
	{
		const int x =partition->partA[i];
		if(lockTable[x]!=lock)
		{
			const int cxai = getSparseDoubleMatrix(g,x,ai);  // Cx,ai
			const int cxbj = getSparseDoubleMatrix(g,x,bj);  // Cx,bj
			D[x] = D[x] + 2*cxai - 2*cxbj;
		}
	}

	// updatd Dy'
	for(i=0;i<partition->partBSize;i++)
	{
		const int y =partition->partB[i];
		if(lockTable[y]!=lock)
		{
			const int cybj = getSparseDoubleMatrix(g,y,bj);  // Cy,bj
			const int cyai = getSparseDoubleMatrix(g,y,ai);  // Cy,ai
			D[y] = D[y] + 2*cybj - 2*cyai;
		}
	}
}


// ==================================================

static int getCutSize(const PartitionResult *partition,const SparseDoubleMatrix *g)
{
	int cutSize = 0;
	int i,j;

	
	for(i=0;i<partition->partASize;i++)
	{
		const int indexA = partition->partA[i];
		for(j=0;j<partition->partBSize;j++)
		{
			const int indexB = partition->partB[j];
			const double connectivity = getSparseDoubleMatrix(g,indexA,indexB);
			if(connectivity != 0) cutSize++;
		}
	}

	return cutSize;
}



// generate the crossList
// A' = A - crossList
// B' = B - crossList
static void refinePartitionResult(PartitionResult *result,const SparseDoubleMatrix *g)
{
	// init
	const int origASize = result->partASize;
	const int origBSize = result->partBSize;
	int *crossLogA = getMempoolSet(sizeof(int)*origASize);	
	int *crossLogB = getMempoolSet(sizeof(int)*origBSize);
	memset(crossLogA,0,sizeof(int)*origASize);
	memset(crossLogB,0,sizeof(int)*origBSize);
	int i,j;

	// calculate the cross terms
/*
	for(i=0;i<origASize;i++)
	{
		const int indexA = result->partA[i];
		for(j=0;j<origBSize;j++)
		{
			const int indexB = result->partB[j];
			const double connectivity = getSparseDoubleMatrix(g,indexA,indexB);
			if(connectivity != 0)
			{
				crossLogA[i] = 1;
				crossLogB[j] = 1;
			}
		}
	}
*/
	//==============================================
		
	// A: 1 B: 2
	int *mark = getMempoolSet(sizeof(int)*g->totalRow);
	memset(mark,0,sizeof(int)*g->totalRow);
	int *indexLogA = getMempoolSet(sizeof(int)*g->totalRow);
	int *indexLogB = getMempoolSet(sizeof(int)*g->totalRow);
	for(i=0;i<g->totalRow;i++) indexLogA[i] = indexLogB[i] = -1;
	
	for(i=0;i<origASize;i++)
	{
		mark[result->partA[i]] = 1;
		indexLogA[result->partA[i]] = i;
	}
	for(i=0;i<origBSize;i++)
	{
		mark[result->partB[i]] = 2;
		indexLogB[result->partB[i]] = i;
	}


	for(i=0;i<g->totalRow;i++)
	{
		SparseDoubleElement *ptr = g->rowIndex[i]->rowLink;
		while(ptr!=NULL)
		{
			const int col = ptr->col;
			if(mark[i] == 1 && mark[col] == 2)
			{
				crossLogA[indexLogA[i]] = 1;
				crossLogB[indexLogB[col]] = 1;
			}
			else if(mark[i] == 2 && mark[col] == 1)
			{
				crossLogA[indexLogA[col]] = 1;
				crossLogB[indexLogB[i]] = 1;
			}
			ptr = ptr->rowLink;
		}
	}
	retMempoolSet(mark,sizeof(int)*g->totalRow);
	retMempoolSet(indexLogA,sizeof(int)*g->totalRow);
	retMempoolSet(indexLogB,sizeof(int)*g->totalRow);

	//==============================================

	// output the refined result to temp
	PartitionResult *temp = createPartitionResult(result->partitionSize);
	for(i=0;i<origASize;i++)
	{
		const int indexA = result->partA[i];
		if(crossLogA[i] == 0) insertToPartitionResult(temp,indexA,'A'); 
		else insertToPartitionResult(temp,indexA,'C'); 
	}
	for(i=0;i<origBSize;i++)
	{
		const int indexB = result->partB[i];
		if(crossLogB[i] == 0) insertToPartitionResult(temp,indexB,'B'); 
		else insertToPartitionResult(temp,indexB,'C'); 
	}


	srand(0);
	// random shuffle
	for(i=0;i<4*temp->crossListSize;i++)
	{
		const int index1 = rand()%temp->crossListSize;
		const int index2 = rand()%temp->crossListSize;
		int tmp = temp->crossList[index1];
		temp->crossList[index1] = temp->crossList[index2];
		temp->crossList[index2] = tmp;
	}


//	printf("cross Size = %d\n",temp->crossListSize);
	for(i=0;i<temp->crossListSize;i++)
	{
		const int indexC = temp->crossList[i];
		int flag = 0;
		for(j=0;j<origASize;j++)
		{
			if(indexC == result->partA[j])
			{
				flag = 1;
				break;
			}
		}
		for(j=0;j<origBSize;j++)
		{
			if(indexC == result->partB[j])
			{
				flag = 2;
				break;
			}
		}
		if(flag == 0)
		{
			printf(" *** WTF\n ***");
		}

		if(flag == 1) // cross term is original in partA
		{
			// check does it have connection with "tempPartB"
			// add to temp partA if it is ok
			// set temp crossList[i] = -1;
			int k;
			int connectFlag = 0;
			for(k=0;k<temp->partBSize;k++)
			{
				const int indexB = temp->partB[k];
				const double connectivity = getSparseDoubleMatrix(g,indexC,indexB);
				if(connectivity != 0)
				{
					connectFlag = 1;
					break;
				}
			}
			if(connectFlag == 0)
			{
				insertToPartitionResult(temp,indexC,'A');
				temp->crossList[i] = -1;
			}
		}
		else // flag == 2, cross term is original in partB
		{
			// check does it have connection with "tempPartA"
			// add to temp partB if it is ok
			// set temp crossList[i] = -1;
			int k;
			int connectFlag = 0;
			for(k=0;k<temp->partASize;k++)
			{
				const int indexA = temp->partA[k];
				const double connectivity = getSparseDoubleMatrix(g,indexC,indexA);
				if(connectivity != 0)
				{
					connectFlag = 1;
					break;
				}
			}
			if(connectFlag == 0)
			{
				insertToPartitionResult(temp,indexC,'B');
				temp->crossList[i] = -1;
			}
		}
	}



	// copy from temp to result
	result->partASize = temp->partASize;
	result->partBSize = temp->partBSize;
	result->crossListSize = temp->crossListSize;

	memcpy(result->partA,temp->partA,temp->partASize*sizeof(int));
	memcpy(result->partB,temp->partB,temp->partBSize*sizeof(int));
	memcpy(result->crossList,temp->crossList,temp->crossListSize*sizeof(int));

	
	// cross refinement
	j = 0;
	for(i=0;i<temp->crossListSize;i++)
	{
		if(temp->crossList[i] == -1)
		{
			result->crossListSize--;
		}
		else
		{
			result->crossList[j] = temp->crossList[i];
			j++;
		}
	}



	// free
	freePartitionResult(temp);
	retMempoolSet(crossLogA,sizeof(int)*origASize);	
	retMempoolSet(crossLogB,sizeof(int)*origBSize);
}





static void refinePartitionResultBackup(PartitionResult *result,const SparseDoubleMatrix *g)
{
	// init
	const int origASize = result->partASize;
	const int origBSize = result->partBSize;
	int *crossLogA = getMempoolSet(sizeof(int)*origASize);	
	int *crossLogB = getMempoolSet(sizeof(int)*origBSize);
	memset(crossLogA,0,sizeof(int)*origASize);
	memset(crossLogB,0,sizeof(int)*origBSize);
	int i,j;

	// calculate the cross terms
	for(i=0;i<origASize;i++)
	{
		const int indexA = result->partA[i];
		for(j=0;j<origBSize;j++)
		{
			const int indexB = result->partB[j];
			const double connectivity = getSparseDoubleMatrix(g,indexA,indexB);
			if(connectivity != 0)
			{
				crossLogA[i] = 1;
				crossLogB[j] = 1;
			}
		}
	}

	// output the refined result to temp
	PartitionResult *temp = createPartitionResult(result->partitionSize);
	for(i=0;i<origASize;i++)
	{
		const int indexA = result->partA[i];
		if(crossLogA[i] == 0) insertToPartitionResult(temp,indexA,'A'); 
		else insertToPartitionResult(temp,indexA,'C'); 
	}
	for(i=0;i<origBSize;i++)
	{
		const int indexB = result->partB[i];
		if(crossLogB[i] == 0) insertToPartitionResult(temp,indexB,'B'); 
		else insertToPartitionResult(temp,indexB,'C'); 
	}

	// copy from temp to result
	result->partASize = temp->partASize;
	result->partBSize = temp->partBSize;
	result->crossListSize = temp->crossListSize;

	memcpy(result->partA,temp->partA,temp->partASize*sizeof(int));
	memcpy(result->partB,temp->partB,temp->partBSize*sizeof(int));
	memcpy(result->crossList,temp->crossList,temp->crossListSize*sizeof(int));

	// free
	freePartitionResult(temp);
	retMempoolSet(crossLogA,sizeof(int)*origASize);	
	retMempoolSet(crossLogB,sizeof(int)*origBSize);
}






// ==================================================


static void fastKL(PartitionResult *result, const SparseDoubleMatrix *g,const PartitionResult *init)
{
	
	// ===============   below is the KL body    ===================
	int i,j,k;
//	const int gSize = 2 * init->partitionSize;
	const int gSize = g->totalRow;

	int *I = getMempoolSet(sizeof(int)*gSize);
	int *E = getMempoolSet(sizeof(int)*gSize);
	int *D = getMempoolSet(sizeof(int)*gSize);
	memset(I,0,sizeof(int)*gSize);
	memset(E,0,sizeof(int)*gSize);
	memset(D,0,sizeof(int)*gSize);

	enum LockStat *lockTable = getMempoolSet(gSize*sizeof(enum LockStat));
	for(i=0;i<gSize;i++) lockTable[i] = unlock;	

	// calculate I
	for(i=0;i<init->partASize;i++)
	{
		const int indexSrc = init->partA[i];
		for(j=0;j<init->partASize;j++)
		{
			if(i==j) continue;
			else
			{
				const int indexDest = init->partA[j];
				const double connectivity = getSparseDoubleMatrix(g,indexSrc,indexDest);
				if(connectivity != 0) I[indexSrc]++;
			}
		}
	}
	for(i=0;i<init->partBSize;i++)
	{
		const int indexSrc = init->partB[i];
		for(j=0;j<init->partBSize;j++)
		{
			if(i==j) continue;
			else
			{
				const int indexDest = init->partB[j];
				const double connectivity = getSparseDoubleMatrix(g,indexSrc,indexDest);
				if(connectivity != 0) I[indexSrc]++;
			}
		}
	}

	// calculate E
	for(i=0;i<init->partASize;i++)
	{
		const int indexA = init->partA[i];
		for(j=0;j<init->partBSize;j++)
		{
			const int indexB = init->partB[j];
			const double connectivity = getSparseDoubleMatrix(g,indexA,indexB);
			if(connectivity != 0) E[indexA]++;
		}
	}
	for(i=0;i<init->partBSize;i++)
	{
		const int indexB = init->partB[i];
		for(j=0;j<init->partASize;j++)
		{
			const int indexA = init->partA[j];
			const double connectivity = getSparseDoubleMatrix(g,indexA,indexB);
			if(connectivity != 0) E[indexB]++;
		}
	}

	// calculate D
	for(i=0;i<gSize;i++) D[i] = E[i] - I[i];

/*
	for(i=0;i<gSize;i++)
	{
		fprintf(stderr,"I[%d]: %d , E[%d]: %d , D[%d]%d\n",i,I[i],i,E[i],i,D[i]);
	}
*/

	// actual swap
	while(1)
	{
		int gain = INT_MIN;
		int candidateA = -1;
		int candidateB = -1;
		for(j=0;j<init->partASize;j++)
		{
			const int valInPartA = init->partA[j];
			if(lockTable[valInPartA] == lock) continue;
			for(k=0;k<init->partBSize;k++)
			{
				const int valInPartB = init->partB[k];
				if(lockTable[valInPartB] == lock) continue;
				else
				{
					const int currentGain = D[valInPartA] + D[valInPartB] - 2*getSparseDoubleMatrix(g,valInPartA,valInPartB);
					if(currentGain>gain && currentGain>0)
					{
						gain = currentGain;
						candidateA = valInPartA;
						candidateB = valInPartB;
					}
				}
			}
		}
		if(gain > 0)
		{
			lockTable[candidateA] = lock;
			lockTable[candidateB] = lock;
			updataD(D,g,candidateA,candidateB,init,lockTable);
			insertToPartitionResult(result,candidateB,'A');
			insertToPartitionResult(result,candidateA,'B');
//			fprintf(stderr,"part a: %d\n",candidateB);
//			fprintf(stderr,"part b: %d\n",candidateA);
		}
		else
		{
			// insert the remaining unlock element to result
			for(i=0;i<init->partASize;i++)
			{
				const int valInPartA = init->partA[i];
				if(lockTable[valInPartA] == lock) continue;
				else
				{
//					fprintf(stderr,"part a: %d\n",valInPartA);
					insertToPartitionResult(result,valInPartA,'A');
				}
			}
			for(i=0;i<init->partBSize;i++)
			{
				const int valInPartB = init->partB[i];
				if(lockTable[valInPartB] == lock) continue;
				else
				{
//					fprintf(stderr,"part b: %d\n",valInPartB);
					insertToPartitionResult(result,valInPartB,'B');
				}
			}

			break;
		}
	}
	refinePartitionResult(result,g);
	// ===============   above is the KL body    ===================

//	for(i=0;i<result->crossListSize;i++) fprintf(stderr,"cross: %d\n",result->crossList[i]);
	
	retMempoolSet(I,sizeof(int)*gSize);
	retMempoolSet(E,sizeof(int)*gSize);
	retMempoolSet(D,sizeof(int)*gSize);
	retMempoolSet(lockTable,gSize*sizeof(enum LockStat));
}


// ==================================================





static EliminationTree *createEliminationTree(const int size)
{
	EliminationTree *ptr = getMempoolSet(sizeof(EliminationTree));
	ptr->size = size;
	ptr->node = getMempoolSet(size*sizeof(PartitionResult *));
	memset(ptr->node,0,sizeof(PartitionResult *)*size);

	ptr->count = 1;

	return ptr;
}



static void freeEliminationTree(EliminationTree *ptr)
{
	int i;
	for(i=0;i<ptr->size;i++)
	{
		if(ptr->node[i]!=NULL) freePartitionResult(ptr->node[i]);
	}
	retMempoolSet(ptr->node,ptr->size*sizeof(PartitionResult *));
	retMempoolSet(ptr,sizeof(EliminationTree));
}



static void insertEliminationTree(EliminationTree *tree,const PartitionResult *node)
{
	if(tree->count == tree->size)
	{
		fprintf(stderr,"Elimination tree construction error\n");
		exit(0);
	}
	else
	{
		tree->node[tree->count] = createPartitionResult(node->partitionSize);
		tree->node[tree->count]->partASize = node->partASize;
		tree->node[tree->count]->partBSize = node->partBSize;
		tree->node[tree->count]->crossListSize = node->crossListSize;

		memcpy(tree->node[tree->count]->partA,node->partA,node->partASize*sizeof(int));
		memcpy(tree->node[tree->count]->partB,node->partB,node->partBSize*sizeof(int));
		memcpy(tree->node[tree->count]->crossList,node->crossList,node->crossListSize*sizeof(int));
		
		tree->count++;
	}
}



static void postOrder(int *orderList,const EliminationTree *tree)
{
	int orderListCounter = 0;
	int currentIndex = 1;
	PartitionResult* currentNode;
	while(1)
	{
		currentNode = tree->node[currentIndex];

		if(currentNode == NULL) break;
		
		const PartitionResult *currentLeft = tree->node[2*currentIndex];
		const PartitionResult *currentRight = tree->node[2*currentIndex+1];
		if(currentLeft!=NULL && currentLeft->visitLog != visit)
		{
			currentIndex = currentIndex*2;
		}
		else if(currentRight!=NULL && currentRight->visitLog != visit)
		{
			currentIndex = currentIndex*2 + 1;
		}
		else if(currentNode->visitLog!=visit) // print out the "N"
		{
			currentNode->visitLog = visit;
			if(currentNode->partASize!=0)
			{
				int j;
				for(j=0;j<currentNode->partASize;j++)
				{
					orderList[orderListCounter] = currentNode->partA[j];
					orderListCounter++;
//					fprintf(stderr,"%d ",currentNode->partA[j]);
				}
//				fprintf(stderr,"\n");
			}
			else if(currentNode->crossListSize!=0)
			{
				int j;
				for(j=0;j<currentNode->crossListSize;j++)
				{
					orderList[orderListCounter] = currentNode->crossList[j];
					orderListCounter++;
//					fprintf(stderr,"%d ",currentNode->crossList[j]);
				}
//				fprintf(stderr,"\n");
			}
			else
			{
//				fprintf(stderr,"error in tree\n");
//				exit(0);
			}
		}
		else
		{
			currentIndex = currentIndex/2;
		}
	}
}



static void partition(EliminationTree *tree,const SparseDoubleMatrix *g,const int goalPartition)
{
	int i;
	SparseDoubleMatrix *gTrans = createSparseDoubleMatrix(g->totalRow,g->totalCol);
	SparseDoubleMatrix *gMap = createSparseDoubleMatrix(g->totalRow,g->totalCol);
	transSparseDoubleMatrix(gTrans,g);
	addSparseDoubleMatrix(gMap,g,gTrans);

	for(i=0;i<gMap->totalRow;i++)
	{
		const SparseDoubleElement *eachRow = gMap->rowIndex[i]->rowLink;
		while(eachRow!=NULL)
		{
			const int setRow = i;
			const int setCol = eachRow->col;
			const double val = 1.0;
			setSparseDoubleMatrix(gMap,val,setRow,setCol);
			eachRow = eachRow->rowLink;
		}
	}

	// initial partitinon
	PartitionResult *init = createPartitionResult((g->totalRow+1)/2);

	for(i=0;i<gMap->totalRow/2;i++)
	{
		insertToPartitionResult(init,i,'A');
	}
	for(i=gMap->totalRow/2;i<gMap->totalRow;i++)
	{
		insertToPartitionResult(init,i,'B');
	}

	PartitionResult *result = createPartitionResult((g->totalRow+1)/2 );	
	fprintf(stderr,"\tbefore fast KL\n");
	fastKL(result,gMap,init);
	fprintf(stderr,"\tend fast KL\n");
	
	PartitionResult *nodeToTree;
	nodeToTree = allocAndCopyPartitionResult(result,'C');
	insertEliminationTree(tree,nodeToTree);
	freePartitionResult(nodeToTree);

	gdsl_queue_t partitionResultQueue = gdsl_queue_alloc("partitionList",alloc_partitionResult,free_partitionResult); 

	PartitionResult *resultToQueueA = createPartitionResult(result->partASize);
	for(i=0;i<result->partASize;i++)
	{
		const int val = result->partA[i];
		insertToPartitionResult(resultToQueueA,val,'A');
	}
	gdsl_queue_insert(partitionResultQueue,resultToQueueA);
	freePartitionResult(resultToQueueA);

	PartitionResult *resultToQueueB = createPartitionResult(result->partBSize);
	for(i=0;i<result->partBSize;i++)
	{
		const int val = result->partB[i];
		insertToPartitionResult(resultToQueueB,val,'A');
	}
	gdsl_queue_insert(partitionResultQueue,resultToQueueB);
	freePartitionResult(resultToQueueB);

	int currentPartition;
	for(currentPartition=2;currentPartition<goalPartition && gdsl_queue_get_size(partitionResultQueue)>0 ;currentPartition++)
	{
		PartitionResult *currentNode = gdsl_queue_get_head(partitionResultQueue);
		PartitionResult *currentInit = createPartitionResult((currentNode->partASize+1)/2);
		PartitionResult *currentResult = createPartitionResult((currentNode->partASize+1)/2);

		for(i=0;i<currentNode->partASize/2;i++)
		{
			const int val = currentNode->partA[i];
			insertToPartitionResult(currentInit,val,'A');
		}
		for(i=currentNode->partASize/2;i<currentNode->partASize;i++)
		{
			const int val = currentNode->partA[i];
			insertToPartitionResult(currentInit,val,'B');
		}

		fastKL(currentResult,gMap,currentInit);
		
		// insert to elimination tree
		nodeToTree = allocAndCopyPartitionResult(currentResult,'C');
		insertEliminationTree(tree,nodeToTree);
		freePartitionResult(nodeToTree);

		// insert to partition queue
		PartitionResult *currentResultA = createPartitionResult(currentResult->partASize);
		for(i=0;i<currentResult->partASize;i++)
		{
			const int val = currentResult->partA[i];
			insertToPartitionResult(currentResultA,val,'A');
		}
		gdsl_queue_insert(partitionResultQueue,currentResultA);
		freePartitionResult(currentResultA);

		PartitionResult *currentResultB = createPartitionResult(currentResult->partBSize);
		for(i=0;i<currentResult->partBSize;i++)
		{
			const int val = currentResult->partB[i];
			insertToPartitionResult(currentResultB,val,'A');
		}
		gdsl_queue_insert(partitionResultQueue,currentResultB);
		freePartitionResult(currentResultB);
		
		gdsl_queue_remove(partitionResultQueue);

		freePartitionResult(currentResult);
		freePartitionResult(currentInit);
		freePartitionResult(currentNode);
	}	


	while(gdsl_queue_get_size(partitionResultQueue) > 0)
	{
		PartitionResult *currentNode = gdsl_queue_get_head(partitionResultQueue);
		
		// insert to elimination tree
		nodeToTree = allocAndCopyPartitionResult(currentNode,'A');
		insertEliminationTree(tree,nodeToTree);
		freePartitionResult(nodeToTree);

		gdsl_queue_remove(partitionResultQueue);
		freePartitionResult(currentNode);
	}

/*
	// output the elimination tree
	for(i=1;i<tree->size;i++)	
	{
		PartitionResult *currentNode = tree->node[i];
		if(currentNode==NULL) continue;
		if(currentNode->partASize!=0)
		{
			int j;
			for(j=0;j<currentNode->partASize;j++)
			{
				fprintf(stderr,"%d ",currentNode->partA[j]);
			}
			fprintf(stderr,"\n");
		}
		else if(currentNode->crossListSize!=0)
		{
			int j;
			for(j=0;j<currentNode->crossListSize;j++)
			{
				fprintf(stderr,"%d ",currentNode->crossList[j]);
			}
			fprintf(stderr,"\n");
		}
		else
		{
//			fprintf(stderr,"error in tree\n");
//			exit(0);
		}
	}
*/

	gdsl_queue_free(partitionResultQueue);
	freePartitionResult(init);
	freeSparseDoubleMatrix(gTrans);
	freeSparseDoubleMatrix(gMap);
	freePartitionResult(result);
}



static void paritionMetis(EliminationTree *tree, const SparseDoubleMatrix *a,const int goalPartition)
{
	SparseDoubleMatrix *aTrans = createSparseDoubleMatrix(a->totalRow,a->totalCol);
	SparseDoubleMatrix *aMap = createSparseDoubleMatrix(a->totalRow,a->totalCol);
	transSparseDoubleMatrix(aTrans,a);
	addSparseDoubleMatrix(aMap,a,aTrans);

	int i,j;
	int n = a->totalRow;
	int wgtflag = 0;
	int numflag = 0;
	int nparts = goalPartition;
	int options[5] = {0,0,0,0,0};
	int edgecut = 0;
	int *part = getMempoolSet(sizeof(int)*n);


	idxtype *xadj = getMempoolSet(sizeof(idxtype)*(a->totalRow+1));
	idxtype *adjncy = getMempoolSet(sizeof(idxtype)*(a->nnz-a->totalRow));
	sparseDoubleMatrix2MetisXADJ(xadj,aMap);
	sparseDoubleMatrix2MetisADJNCY(adjncy,aMap);
	METIS_PartGraphRecursive(&n,xadj,adjncy,NULL,NULL,&wgtflag,&numflag,&nparts,options,&edgecut,part);
	retMempoolSet(xadj,sizeof(idxtype)*(a->totalRow+1));
	retMempoolSet(adjncy,sizeof(idxtype)*(a->nnz-a->totalRow));

	gdsl_queue_t partitionResultQueue = gdsl_queue_alloc("partitionList",alloc_partitionResult,free_partitionResult); 

	PartitionResult* initPartitionResult = createPartitionResult(n);
	for(i=0;i<n;i++) insertToPartitionResult(initPartitionResult,i,'A');
	initPartitionResult->partSerialBegin = 0;
	initPartitionResult->partSerialEnd = goalPartition-1;
	gdsl_queue_insert(partitionResultQueue,initPartitionResult);
	freePartitionResult(initPartitionResult);


	for(i=0;i<goalPartition-1;i++)
	{
		PartitionResult* currentPartitionResult = gdsl_queue_get_head(partitionResultQueue);
		PartitionResult* currentToRefine = createPartitionResult(currentPartitionResult->partASize);
		const int partSerialBegin = currentPartitionResult->partSerialBegin;
		const int partSerialEnd = currentPartitionResult->partSerialEnd;
		const int separate = partSerialBegin + (partSerialEnd - partSerialBegin +1)/2;
/*
		fprintf(stderr,"begin:%d ,end:%d, mid:%d\n",partSerialBegin,partSerialEnd,separate);
		fprintf(stderr,"partASize:%d\n",currentPartitionResult->partASize);
		for(j=0;j<n;j++) fprintf(stderr,"%d ",part[j]);
		fprintf(stderr,"\n");
*/
		for(j=0;j<currentPartitionResult->partASize;j++)
		{
			const int data = currentPartitionResult->partA[j];
			if(part[data]<separate) // for part A
			{
				insertToPartitionResult(currentToRefine,data,'A'); // flag = 'A' or flag = 'B'
			}
			else if(part[data]>=separate) // for partB
			{
				insertToPartitionResult(currentToRefine,data,'B'); // flag = 'A' or flag = 'B'
			}
		}
//		time_t t1,t2,t3;
		
//		time(&t1);
		refinePartitionResult(currentToRefine,aMap);
//		time(&t2);

		PartitionResult *nodeToTree;
		nodeToTree = allocAndCopyPartitionResult(currentToRefine,'C');
		insertEliminationTree(tree,nodeToTree);
		freePartitionResult(nodeToTree);
//		time(&t3);
		
//		printf("t2-t1:%g\tt3-t2:%g\n",difftime(t2,t1),difftime(t3,t2));

		PartitionResult *currentToRefineA = createPartitionResult(currentToRefine->partASize);
		for(j=0;j<currentToRefine->partASize;j++)
		{
			const int val = currentToRefine->partA[j];
			insertToPartitionResult(currentToRefineA,val,'A');
		}
		currentToRefineA->partSerialBegin = partSerialBegin;
		currentToRefineA->partSerialEnd = separate-1;
		gdsl_queue_insert(partitionResultQueue,currentToRefineA);
		freePartitionResult(currentToRefineA);

		PartitionResult *currentToRefineB = createPartitionResult(currentToRefine->partBSize);
		for(j=0;j<currentToRefine->partBSize;j++)
		{
			const int val = currentToRefine->partB[j];
			insertToPartitionResult(currentToRefineB,val,'A');
		}
		currentToRefineB->partSerialBegin = separate;
		currentToRefineB->partSerialEnd = partSerialEnd;
		gdsl_queue_insert(partitionResultQueue,currentToRefineB);
		freePartitionResult(currentToRefineB);

		gdsl_queue_remove(partitionResultQueue);
		freePartitionResult(currentPartitionResult);
		freePartitionResult(currentToRefine);
	}
	fprintf(stderr,".....................\n");

	for(i=0;i<goalPartition;i++)
	{
		PartitionResult* currentPartitionResult = gdsl_queue_get_head(partitionResultQueue);
		insertEliminationTree(tree,currentPartitionResult);
		gdsl_queue_remove(partitionResultQueue);
		freePartitionResult(currentPartitionResult);
	}
		
	retMempoolSet(part,sizeof(int)*n);
	freeSparseDoubleMatrix(aTrans);
	freeSparseDoubleMatrix(aMap);
}



static void getPermutation(SparseDoubleMatrix *p,const EliminationTree *tree)
{
	int i;
	// the order list
	int *orderList = getMempoolSet(p->totalRow*sizeof(int));
	postOrder(orderList,tree);
	postorder2Permutation(p,orderList);
	retMempoolSet(orderList,p->totalRow*sizeof(int));
}


static void renameingETree(EliminationTree *tree, const SparseDoubleMatrix *p)
{
	int i;
	// the tree renaming
	for(i=1;i<tree->size;i++)	
	{
		PartitionResult *currentNode = tree->node[i];
		if(currentNode==NULL) continue;
		if(currentNode->partASize!=0)
		{
			int j;
			for(j=0;j<currentNode->partASize;j++)
			{
				int oldVal = currentNode->partA[j];
				int newVal = p->colIndex[oldVal]->colLink->row;
				currentNode->partA[j] = newVal;
//				fprintf(stderr,"%d ",currentNode->partA[j]);
			}
//			fprintf(stderr,"\n");
		}
		else if(currentNode->crossListSize!=0)
		{
			int j;
			for(j=0;j<currentNode->crossListSize;j++)
			{
				int oldVal = currentNode->crossList[j];
				int newVal = p->colIndex[oldVal]->colLink->row;
				currentNode->crossList[j] = newVal;
//				fprintf(stderr,"%d ",currentNode->crossList[j]);
			}
//			fprintf(stderr,"\n");
		}
	}
}


static ParallelETreeNode *createParallelETreeNode(void)
{
	ParallelETreeNode *ptr = getMempoolSet(sizeof(ParallelETreeNode));
	ptr->rowBegin = ptr->rowEnd = -1;
	ptr->doneRowBegin = INT_MAX;
	ptr->doneRowEnd = INT_MIN;
	ptr->visitLog = notvisit; 
	ptr->type = undefine;
	return ptr;
}


static void freeParallelETreeNode(ParallelETreeNode *ptr)
{
	if(ptr!=NULL)
	{
		retMempoolSet(ptr,sizeof(ParallelETreeNode));
	}
}


ParallelETree *createParallelETree(const int size)
{
	ParallelETree *ptr = getMempoolSet(sizeof(ParallelETree));
	ptr->size = size;
	ptr->node = getMempoolSet(size*sizeof(ParallelETreeNode *));
	memset(ptr->node,0,sizeof(ParallelETreeNode *)*size);

	return ptr;
}


void freeParallelETree(ParallelETree *ptr)
{
	int i;
	for(i=0;i<ptr->size;i++)
	{
		freeParallelETreeNode(ptr->node[i]);
	}
	retMempoolSet(ptr->node,ptr->size*sizeof(ParallelETreeNode *));
	retMempoolSet(ptr,sizeof(ParallelETree));
}


static void copyFromEliminationTreeToParallelETree(ParallelETree *dest, const EliminationTree *src)
{
	if(dest->size != src->size)
	{
		fprintf(stderr,"convert from E-tree to Parall-E-tree error\n");
		exit(0);
	}
	int i,j;
	for(i=0;i<src->size;i++)
	{
		const PartitionResult *srcPtr = src->node[i];
		if(srcPtr==NULL) continue;
		else
		{
			dest->node[i] = createParallelETreeNode();
			if(srcPtr->partASize!=0)
			{
				dest->node[i]->rowBegin = srcPtr->partA[0];
				dest->node[i]->rowEnd = srcPtr->partA[srcPtr->partASize-1];
				dest->node[i]->type = lu;
			}
			else if(srcPtr->crossListSize!=0)
			{
				dest->node[i]->rowBegin = srcPtr->crossList[0];
				dest->node[i]->rowEnd = srcPtr->crossList[srcPtr->crossListSize-1];
				dest->node[i]->type = cross;
			}
		}
	}
}




static void roughPartition(ParallelETree *tree, SparseDoubleMatrix *p, const SparseDoubleMatrix *g, const int goalPartition)
{
	EliminationTree *treeTemp= createEliminationTree(goalPartition*2 + goalPartition+1);

	fprintf(stderr,"rough partition\n");
	paritionMetis(treeTemp,g,goalPartition);
	int i;	
	fprintf(stderr,"=========================\n");
	for(i=0;i<treeTemp->size;i++)
	{
		if(treeTemp->node[i]!=NULL)
		{
//			fprintf(stderr,"i=%d, ",i);
//			fprintf(stderr,"partASize:%d, partBSize:%d, crossListSize:%d\n",treeTemp->node[i]->partASize,treeTemp->node[i]->partBSize,treeTemp->node[i]->crossListSize);			
		}
	}
//	fprintf(stderr,"=========================\n");
//	fprintf(stderr,"partition phase 2\n");
	getPermutation(p,treeTemp);
//	fprintf(stderr,"partition phase 3\n");
	renameingETree(treeTemp,p);
//	fprintf(stderr,"partition phase 4\n");
	copyFromEliminationTreeToParallelETree(tree,treeTemp);
//	fprintf(stderr,"partition phase 5\n");
	freeEliminationTree(treeTemp);
//	fprintf(stderr,"partition phase 6\n");
}


// assuming g is already permutated by "p" which is generated by roughPartition
static void refinePartition(SparseDoubleMatrix *pRefine,const ParallelETree *tree, const SparseDoubleMatrix *g)
{
	int i;
	SparseDoubleMatrix *gTrans = createSparseDoubleMatrix(g->totalRow,g->totalCol);
	SparseDoubleMatrix *gMap = createSparseDoubleMatrix(g->totalRow,g->totalCol);
	transSparseDoubleMatrix(gTrans,g);
	addSparseDoubleMatrix(gMap,g,gTrans);
	
	clearSparseDoubleMatrix(pRefine);

	// for all non-empty nodes in tree
	for(i=1;i<tree->size;i++)
	{
		if(tree->node[i]!=NULL)
		{
			const int rowBegin = tree->node[i]->rowBegin;
			const int rowEnd = tree->node[i]->rowEnd;
			const int num = rowEnd - rowBegin + 1;
			if(rowBegin == -1  && rowEnd == -1)
			{
				// no need to refine
			}
			else
			{
				SparseDoubleMatrix *subGMap = createSparseDoubleMatrix(num,num);
				getSubSparseDoubleMatrix(subGMap,gMap,rowBegin,rowBegin,rowEnd,rowEnd);
				int *pInt = getMempoolSet(sizeof(int)*subGMap->totalRow);
				int *ap = getMempoolSet(sizeof(int)*subGMap->totalRow+1);
				int *ai = getMempoolSet(sizeof(int)*subGMap->nnz);
				sparseDoubleMatrix2AmdAi(ai,subGMap);
				sparseDoubleMatrix2AmdAp(ap,subGMap);
				amd_order(num,ap,ai,pInt,NULL,NULL);

				int j;

				SparseDoubleMatrix *pCurrentNode = createSparseDoubleMatrix(num,num);
				postorder2Permutation(pCurrentNode,pInt);
				mergeSparseDoubleMatrix(pRefine,pCurrentNode,pRefine->totalRow,pRefine->totalCol,rowBegin,rowBegin);
				freeSparseDoubleMatrix(pCurrentNode);
	
				freeSparseDoubleMatrix(subGMap);
				retMempoolSet(pInt,sizeof(int)*subGMap->totalRow);
				retMempoolSet(ap,sizeof(int)*subGMap->totalRow+1);
				retMempoolSet(ai,sizeof(int)*subGMap->nnz);
			}
		}
	}

	freeSparseDoubleMatrix(gTrans);
	freeSparseDoubleMatrix(gMap);
}



void amdSparseDoubleMatrix(SparseDoubleMatrix *p,const SparseDoubleMatrix *a)
{
	int *pInt = getMempoolSet(sizeof(int)*a->totalRow);
	int *ap = getMempoolSet(sizeof(int)*a->totalRow+1);
	int *ai = getMempoolSet(sizeof(int)*a->nnz);
	int i;
	const double unit = 1.0;

	sparseDoubleMatrix2AmdAi(ai,a);
	sparseDoubleMatrix2AmdAp(ap,a);
	amd_order(a->totalRow,ap,ai,pInt,NULL,NULL); 
	clearSparseDoubleMatrix(p);

	for(i=0;i<a->totalCol;i++)
	{
//		setSparseDoubleMatrix(p,unit,pInt[i],i); // old
		setSparseDoubleMatrix(p,unit,i,pInt[i]);
	}

	retMempoolSet(pInt,sizeof(int)*a->totalRow);
	retMempoolSet(ap,sizeof(int)*a->totalRow+1);
	retMempoolSet(ai,sizeof(int)*a->nnz);
}



void static updatePermutationMatrix(SparseDoubleMatrix *pRefineP,const SparseDoubleMatrix *pRefine, const SparseDoubleMatrix *p)
{
	SparseDoubleMatrix *destTemp = createSparseDoubleMatrix(pRefineP->totalRow,pRefineP->totalCol);
	int i;
	// permutate row
	for(i=0;i<pRefine->totalRow;i++)
	{
		const int colForRowI = pRefine->rowIndex[i]->rowLink->col;
		const SparseDoubleElement *ptr = p->rowIndex[colForRowI]->rowLink;
		while(ptr!=NULL)
		{
			const int col = ptr->col;
			setSparseDoubleMatrix(destTemp,ptr->data,i,col);			
//			setSparseDoubleMatrix(destTemp,1.0,i,col);			
			ptr = ptr->rowLink;
		}
	}
	
	copySparseDoubleMatrix(pRefineP,destTemp);
	freeSparseDoubleMatrix(destTemp);
}



void partitionSparseDoubleMatrix(SparseDoubleMatrix *p,SparseDoubleMatrix *pTrans,ParallelETree *tree,SparseDoubleMatrix* aRefine,const SparseDoubleMatrix *a,const int goalPartition)
{
	const int nodeNum = a->totalRow;
	roughPartition(tree,p,a,goalPartition);
	transSparseDoubleMatrix(pTrans,p);
	permutateSparseDoubleMatrix(aRefine,p,pTrans,a);	


	fprintf(stderr,"start to amd refinement\n");
	SparseDoubleMatrix *pRefine = createSparseDoubleMatrix(nodeNum,nodeNum);
//	fprintf(stderr,"phase 1\n");
	refinePartition(pRefine,tree,aRefine);
//	fprintf(stderr,"phase 2\n");
	updatePermutationMatrix(p,pRefine,p);
//	fprintf(stderr,"phase 3\n");
	transSparseDoubleMatrix(pTrans,p);
//	fprintf(stderr,"phase 4\n");
	permutateSparseDoubleMatrix(aRefine,p,pTrans,a);	
//	fprintf(stderr,"phase 5\n");
	freeSparseDoubleMatrix(pRefine);
	fprintf(stderr,"end of amd refinement\n");

/*
	int i;
	fprintf(stderr,"===========================\n");
	fprintf(stderr,"rowBegin, rowEnd setting\n");
	for(i=0;i<tree->size;i++)
	{
		if(tree->node[i]!=NULL)	fprintf(stderr,"i:%d,rowBegin:%d, rowEnd:%d\n",i,tree->node[i]->rowBegin,tree->node[i]->rowEnd); 	
	}
	fprintf(stderr,"===========================\n");
*/
}






void partitionSparseDoubleMatrixNew(SparseDoubleMatrix *p,SparseDoubleMatrix *pTrans,ParallelETree *tree,SparseDoubleMatrix *aRefine,const SparseDoubleMatrix *a,const int goalPartition)
{
}
@


1.17
log
@ok version, new partition refinement
@
text
@d327 1
d342 46
d405 12
d1071 1
d1097 1
d1099 1
d1101 2
a1102 1
		
d1107 3
d1137 1
a1283 2
//	fprintf(stderr,"partition phase 1\n");
//	fprintf(stderr,"before to metis\n");
a1284 1
//	fprintf(stderr,"end to metis\n");
@


1.16
log
@ok version ~ wait to new refine function .
@
text
@d403 2
a404 1
//				insertToPartitionResult(temp,indexA,'A'); 
d407 1
a407 1
		else
d409 20
d443 18
@


1.15
log
@ok version
@
text
@d357 56
d429 65
@


1.14
log
@ok version ~ new pid functions
@
text
@d1056 3
a1058 2
	fprintf(stderr,"partition phase 1\n");
	fprintf(stderr,"before to metis\n");
d1060 1
a1060 1
	fprintf(stderr,"end to metis\n");
d1067 2
a1068 2
			fprintf(stderr,"i=%d, ",i);
			fprintf(stderr,"partASize:%d, partBSize:%d, crossListSize:%d\n",treeTemp->node[i]->partASize,treeTemp->node[i]->partBSize,treeTemp->node[i]->crossListSize);			
d1071 2
a1072 2
	fprintf(stderr,"=========================\n");
	fprintf(stderr,"partition phase 2\n");
d1074 1
a1074 1
	fprintf(stderr,"partition phase 3\n");
d1076 1
a1076 1
	fprintf(stderr,"partition phase 4\n");
d1078 1
a1078 1
	fprintf(stderr,"partition phase 5\n");
d1080 1
a1080 1
	fprintf(stderr,"partition phase 6\n");
d1199 1
a1199 1
	fprintf(stderr,"phase 1\n");
d1201 1
a1201 1
	fprintf(stderr,"phase 2\n");
d1203 1
a1203 1
	fprintf(stderr,"phase 3\n");
d1205 1
a1205 1
	fprintf(stderr,"phase 4\n");
d1207 1
a1207 1
	fprintf(stderr,"phase 5\n");
d1211 1
a1211 1

d1220 1
@


1.13
log
@ok version ..
@
text
@d834 1
a842 1

d1057 1
a1057 1
//	partition(treeTemp,g,goalPartition);
d1059 1
a1117 2
	//			for(j=0;j<num;j++) fprintf(stderr,"%d ",pInt[j]);
	//			fprintf(stderr,"\n");
a1201 1
//	mulSparseDoubleMatrix(p,pRefine,p);
@


1.12
log
@*** empty log message ***
@
text
@a1146 2
//	dumpSparseQuadMatrix(stdout,a);

a1149 6
/*
	for(i=0;i<a->totalCol;i++)
	{
		fprintf(stderr,"%d\n",pInt[i]);
	}
*/
@


1.11
log
@*** empty log message ***
@
text
@d1220 9
@


1.10
log
@*** empty log message ***
@
text
@d1101 23
a1123 17
			SparseDoubleMatrix *subGMap = createSparseDoubleMatrix(num,num);
			getSubSparseDoubleMatrix(subGMap,gMap,rowBegin,rowBegin,rowEnd,rowEnd);
			int *pInt = getMempoolSet(sizeof(int)*subGMap->totalRow);
			int *ap = getMempoolSet(sizeof(int)*subGMap->totalRow+1);
			int *ai = getMempoolSet(sizeof(int)*subGMap->nnz);
			sparseDoubleMatrix2AmdAi(ai,subGMap);
			sparseDoubleMatrix2AmdAp(ap,subGMap);
			amd_order(num,ap,ai,pInt,NULL,NULL);

			int j;
//			for(j=0;j<num;j++) fprintf(stderr,"%d ",pInt[j]);
//			fprintf(stderr,"\n");

			SparseDoubleMatrix *pCurrentNode = createSparseDoubleMatrix(num,num);
			postorder2Permutation(pCurrentNode,pInt);
			mergeSparseDoubleMatrix(pRefine,pCurrentNode,pRefine->totalRow,pRefine->totalCol,rowBegin,rowBegin);
			freeSparseDoubleMatrix(pCurrentNode);
d1125 5
a1129 4
			freeSparseDoubleMatrix(subGMap);
			retMempoolSet(pInt,sizeof(int)*subGMap->totalRow);
			retMempoolSet(ap,sizeof(int)*subGMap->totalRow+1);
			retMempoolSet(ai,sizeof(int)*subGMap->nnz);
@


1.9
log
@*** empty log message ***
@
text
@d1057 2
a1058 2
	partition(treeTemp,g,goalPartition);
//	paritionMetis(treeTemp,g,goalPartition);
d1196 2
a1197 1
	
a1209 1

d1212 1
@


1.8
log
@*** empty log message ***
@
text
@d129 2
d145 1
d207 4
d825 1
a825 1
	int i;
a840 1
	retMempoolSet(part,sizeof(int)*n);
d842 11
a852 3
	PartitionResult* initPartitionResult = createPartitionResult(n/2);
	const int separate = goalPartition/2;
	for(i=0;i<n;i++)
d854 12
a865 1
		if(part[i] < separate) // for part A
d867 9
a875 1
			insertToPartitionResult(initPartitionResult,i,'A'); // flag = 'A' or flag = 'B'
d877 10
a886 1
		else // for partB
d888 2
a889 1
			insertToPartitionResult(initPartitionResult,i,'B'); // flag = 'A' or flag = 'B'
d891 15
a905 2
	}
	refinePartitionResult(initPartitionResult,aMap);
d907 3
a909 10
	PartitionResult *nodeToTree;
	nodeToTree = allocAndCopyPartitionResult(initPartitionResult,'C');
	insertEliminationTree(tree,nodeToTree);
	freePartitionResult(nodeToTree);
	
	PartitionResult *resultForA = createPartitionResult(initPartitionResult->partASize);
	for(i=0;i<initPartitionResult->partASize;i++)
	{
		const int val = initPartitionResult->partA[i];
		insertToPartitionResult(resultForA,val,'A');
a910 2
	insertEliminationTree(tree,resultForA);
	freePartitionResult(resultForA);
d912 1
a912 2
	PartitionResult *resultForB = createPartitionResult(initPartitionResult->partBSize);
	for(i=0;i<initPartitionResult->partBSize;i++)
d914 4
a917 2
		const int val = initPartitionResult->partB[i];
		insertToPartitionResult(resultForB,val,'A');
d919 2
a920 12
	insertEliminationTree(tree,resultForB);
	freePartitionResult(resultForB);
/*
	for(i=0;i<initPartitionResult->partASize;i++) fprintf(stderr,"%d ",initPartitionResult->partA[i]);
	fprintf(stderr,"\n");
	for(i=0;i<initPartitionResult->partBSize;i++) fprintf(stderr,"%d ",initPartitionResult->partB[i]);
	fprintf(stderr,"\n");
	for(i=0;i<initPartitionResult->crossListSize;i++) fprintf(stderr,"%d ",initPartitionResult->crossList[i]);
	fprintf(stderr,"\n");
*/

	freePartitionResult(initPartitionResult);
d1057 2
a1058 2
//	partition(treeTemp,g,goalPartition);
	paritionMetis(treeTemp,g,goalPartition);
d1060 1
d1065 1
a1065 2
			fprintf(stderr,"=========================\n");
			fprintf(stderr,"i=%d\n",i);
d1069 1
d1166 24
d1199 1
d1201 4
a1204 1
	mulSparseDoubleMatrix(p,pRefine,p);
d1206 1
a1206 1

d1208 1
@


1.7
log
@*** empty log message ***
@
text
@d811 78
a891 1

a894 3
//	for(i=0;i<p->totalRow;i++) fprintf(stderr,"%d ",orderList[i]);
//	fprintf(stderr,"\n");

a895 1
	
a896 1
//	dumpSparseDoubleMatrix(stderr,p);
d1019 12
a1030 1
	partition(treeTemp,g,goalPartition);
a1139 2
//	mulSparseDoubleMatrix(aRefine,p,a);
//	mulSparseDoubleMatrix(aRefine,aRefine,pTrans);
a1147 13
void partitionSparseDoubleMatrixNew(SparseDoubleMatrix *p,SparseDoubleMatrix *pTrans,ParallelETree *tree,SparseDoubleMatrix *aRefine,const SparseDoubleMatrix *a,const int goalPartition)
{
	int i;
	idxtype *xadj = getMempoolSet(sizeof(idxtype)*(a->totalRow+1));
	idxtype *adjncy = getMempoolSet(sizeof(idxtype)*(a->nnz-a->totalRow));

	int n = a->totalRow;
	int wgtflag = 0;
	int numflag = 0;
	int nparts = goalPartition;
	int options[5] = {0,0,0,0,0};
	int edgecut = 0;
	int *part = getMempoolSet(sizeof(int)*n);
a1148 2
	sparseDoubleMatrix2MetisXADJ(xadj,a);
	sparseDoubleMatrix2MetisADJNCY(adjncy,a);
a1149 1
	METIS_PartGraphRecursive(&n,xadj,adjncy,NULL,NULL,&wgtflag,&numflag,&nparts,options,&edgecut,part);
d1151 2
a1152 2
	for(i=0;i<n;i++) fprintf(stderr,"%d ",part[i]);
	fprintf(stderr,"\n");
@


1.6
log
@*** empty log message ***
@
text
@d3 1
@


1.5
log
@*** empty log message ***
@
text
@d46 51
d1048 1
a1048 4
	mulSparseDoubleMatrix(aRefine,p,a);
	fprintf(stderr,"renaming row done\n");
	mulSparseDoubleMatrix(aRefine,aRefine,pTrans);
	fprintf(stderr,"renaming col done\n");
d1064 24
@


1.4
log
@*** empty log message ***
@
text
@d890 1
a890 1
void roughPartition(ParallelETree *tree, SparseDoubleMatrix *p, const SparseDoubleMatrix *g, const int goalPartition)
d909 1
a909 1
void refinePartition(SparseDoubleMatrix *pRefine,const ParallelETree *tree, const SparseDoubleMatrix *g)
@


1.3
log
@*** empty log message ***
@
text
@d1007 5
a1011 2
	mulSparseDoubleMatrix(aRefine,p,a);
	mulSparseDoubleMatrix(aRefine,aRefine,pTrans);
@


1.2
log
@*** empty log message ***
@
text
@d991 22
@


1.1
log
@Initial revision
@
text
@a44 51
static void sparseDoubleMatrix2MetisADJNCY(idxtype *ai,const SparseDoubleMatrix *a)
{
	const int totalRow = a->totalRow;
	int i;
	int index = 0;
	SparseDoubleElement *current;
	for(i=0;i<totalRow;i++)
	{
		current = a->rowIndex[i]->rowLink;
		while(current!=NULL)
		{
			const int val = current->col;
			if(val == i)
			{
				current = current->rowLink;
				continue;
			}
			else
			{
				ai[index] = val;
				index++;
				current = current->rowLink;
			}
		}
	}
}



static void sparseDoubleMatrix2MetisXADJ(idxtype *ap,const SparseDoubleMatrix *a)
{
	const int totalRow = a->totalRow;
	int i;
	int index = 0;
	int numInRow = 0;
	SparseDoubleElement *current;
	ap[0] = 0;
	for(i=0;i<totalRow;i++)
	{
		current = a->rowIndex[i]->rowLink;
		numInRow = 0;
		while(current!=NULL)
		{
			numInRow++;
			current = current->rowLink;
		}
		ap[i+1] = ap[i] + numInRow;
	}	
	
	for(i=1;i<=totalRow;i++) ap[i] = ap[i] - i;
}
@
