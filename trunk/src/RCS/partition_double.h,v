head	1.7;
access;
symbols;
locks
	d96041:1.7; strict;
comment	@ * @;


1.7
date	2010.09.07.13.05.10;	author d96041;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.01.12.30.40;	author d96041;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.29.13.35.27;	author d96041;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.28.12.54.39;	author r97124;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.25.09.42.34;	author r97124;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.25.07.22.51;	author r97124;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.25.03.01.13;	author r97124;	state Exp;
branches;
next	;


desc
@@


1.7
log
@ok version
@
text
@#ifndef PARTITION_DOUBLE_H
#define PARTITION_DOUBLE_H

#include <limits.h>
#include <gdsl_queue.h>
#include <gdsl_types.h>
#include <metis.h>

#include "sparsedoublematrix.h"
#include "mempool.h"


// ==================================================================
// 		start of the internal structures
// =================================================================

enum LockStat{lock,unlock};
enum VisitStat{visit,notvisit};

struct PartitionResult
{
	int partitionSize;
	int* partA; // element = 0 ~ size-1
	int* partB;

	int partASize;
	int partBSize;

	int *crossList;
	int crossListSize;

	// ===============
	enum VisitStat visitLog;
	// ===============  used for partitionMetis
	int partSerialBegin;
	int partSerialEnd;
};	

typedef struct PartitionResult PartitionResult;


// because it is assumed as complete binary tree, use array format to save this tree
struct EliminationTree
{
	int size; 
	// total node number of the elimination tree
	// the "empty head node" is also included
	PartitionResult **node;
	// the tree nodes
	
	// ============================

	int count;
	// used for internal insertation function
};

typedef struct EliminationTree EliminationTree;


// ==================================================================
// 		end of the internal structures
// ==================================================================


enum ParallelEtreeNodeType{undefine,lu,cross};

struct ParallelETreeNode
{
	int rowBegin;
	int rowEnd;
	int doneRowBegin;
	int doneRowEnd;
	enum VisitStat visitLog;
	enum ParallelEtreeNodeType type;
};

typedef struct ParallelETreeNode ParallelETreeNode;


struct ParallelETree
{
	int size;
	// total node number of the elimination tree
	// the "empty head node" is also included
	ParallelETreeNode **node;
	// the tree nodes
};

typedef struct ParallelETree ParallelETree;

ParallelETree *createParallelETree(const int size);
void freeParallelETree(ParallelETree *ptr);



// =====================================================================================

// use amd directly to reorder the matrix a
void amdSparseDoubleMatrix(SparseDoubleMatrix *p,const SparseDoubleMatrix *a);


void partitionSparseDoubleMatrix(SparseDoubleMatrix *p,SparseDoubleMatrix *pTrans,ParallelETree *tree,SparseDoubleMatrix *aRefine,const SparseDoubleMatrix *a,const int goalPartition);


void partitionSparseDoubleMatrixNew(SparseDoubleMatrix *p,SparseDoubleMatrix *pTrans,ParallelETree *tree,SparseDoubleMatrix *aRefine,const SparseDoubleMatrix *a,const int goalPartition);

#endif
@


1.6
log
@*** empty log message ***
@
text
@a40 10
/*
struct PartitionResultMetis
{
	int partSerialBegin;
	int partSerialEnd;
	PartitionResult *info;	
};

typedef struct PartitionResultMetis PartitionResultMetis;
*/
@


1.5
log
@*** empty log message ***
@
text
@d34 3
d41 10
@


1.4
log
@*** empty log message ***
@
text
@d7 1
d100 4
@


1.3
log
@*** empty log message ***
@
text
@a96 7
// the tree here is assumed already renaming
void roughPartition(ParallelETree *tree, SparseDoubleMatrix *p, const SparseDoubleMatrix *g, const int goalPartition);

// assuming g is already permutated by "p" which is generated by roughPartition
void refinePartition(SparseDoubleMatrix *p,const ParallelETree *tree, const SparseDoubleMatrix *g);


@


1.2
log
@*** empty log message ***
@
text
@d103 3
@


1.1
log
@Initial revision
@
text
@a6 1
#include <metis.h>
@
